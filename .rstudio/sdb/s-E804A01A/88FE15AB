{
    "contents" : "\n\n\n\n\n\nupdateMarks <- function(data=dt.spy,  dt.portfolio, chr.trade_date) {\n  \n  dt.slim <- data[trade_date==chr.trade_date]\n  dt.portfolio.slim <- dt.portfolio[trade_date == max(dt.portfolio$trade_date)]\n  #remove closed trades\n  dt.portfolio.slim <- dt.portfolio.slim[!trade_id %in% dt.portfolio.slim[qty==0]$trade_id]\n  if (nrow(dt.portfolio.slim) == 0) { return (dt.portfolio) }\n  dt.update <- merge(dt.slim, dt.portfolio.slim[,list(symbol,trade_date=chr.trade_date, expiration, strike, call_put, qty, trade_id)], by=c('symbol','trade_date','expiration','strike','call_put'))\n  dt.portfolio <- rbind(dt.portfolio, dt.update)\n  return(dt.portfolio)\n  \n  \n}\n\n\n\ngetPortfolioMtm <- function(dt.portfolio) {\n  \n  dt.mtm <- data.table()\n  for ( j in unique(dt.portfolio$trade_id)) {\n    temp <- dt.portfolio[trade_id == j][qty!=0][order(trade_date)]\n    temp[,yest_ask:=c(NA, temp[,ifelse(qty>0, ask, bid)*qty][-nrow(temp)])]\n    temp[,dmtm:=ifelse(is.na(yest_ask) == T, 0,ifelse(qty>0, ask, bid)*qty-yest_ask)]\n    dt.mtm <- rbind(dt.mtm, temp)[order(trade_id, trade_date)]\n    \n  }\n  return(dt.mtm)\n  \n}\n\n\n\ngetExpirations <- function(connSettings=con) {\n  \n  dt.expirations <- data.table(dbGetQuery(conn = connSettings,statement = 'select expiration, month(expiration) month, year(expiration) year, sum(trade_volume) trade_volume \n                                     from import_livevol.spy group by expiration  '))\n  dt.expirations <-  merge(dt.expirations,dt.expirations[,list(trade_volume=max(trade_volume)), by=list(month,year)], by=c('month','year','trade_volume'))\n  return(dt.expirations[,list(expiration)])\n}\n\n\ngetBestOption <- function(data=dt.spy, \n                          chr.trade_date, \n                          chr.expiration, \n                          chr.option_type, \n                          int.min_delta = NULL,\n                          int.strike = NULL,\n                          chr.money_in_out = NULL, \n                          int.min_dollar = NULL ) {\n  \n  if(nrow(data[chr.trade_date==trade_date]) == 0) {warning(\"No results\"); return(NA)}\n  if(nrow(data[chr.expiration==expiration ]) == 0) {warning(\"No results\"); return(NA)}\n  if(is.null(int.min_delta) & is.null(int.strike) & (is.null(chr.money_in_out) & is.null(int.min_dollar))) { warning(\"Must have delta/strike or in-out combo\") ;return(NA) }\n  \n  \n  if ( !is.null(int.strike) ) {\n    dt.result <- data[trade_date == chr.trade_date & expiration==chr.expiration & call_put == chr.option_type & strike == int.strike ] \n    if(nrow(dt.result) > 0) {return(dt.result[1,])} else {warning(\"No results\"); return(NA)}\n  }\n  \n  if ( !is.null(int.min_delta)) {\n    dt.result <- data[trade_date == chr.trade_date & expiration==chr.expiration & call_put == chr.option_type & abs(delta) <= int.min_delta ][order(-abs(delta))]\n    if(nrow(dt.result) > 0) {return(dt.result[1,])} else {warning(\"No results\"); return(NA)}\n  }\n  \n  int.money_in_out <- ifelse(chr.money_in_out == 'in', 1, -1)\n  \n  if (int.money_in_out > 0 ) {\n    dt.result <- data[trade_date == chr.trade_date & expiration==chr.expiration & call_put == chr.option_type & distance_from_underlying >= int.money_in_out*int.min_dollar ][order(distance_from_underlying)]\n  } else {\n    dt.result <- data[trade_date == chr.trade_date & expiration==chr.expiration & call_put == chr.option_type & distance_from_underlying <= int.money_in_out*int.min_dollar ][order(-distance_from_underlying)]\n  }\n  \n  if (nrow(dt.result) == 0) { warning(\"No results Returned\"); return(NA) } else { return(dt.result[1,]) }\n  \n  \n}\n\n\n\ngetRangeAcceptableDelta <- function(data=dt.spy, chr.trade_date, dt.portfolio) {\n  \n  dt.atm <- getBestOption(data=dt.spy, \n                          chr.trade_date = chr.trade_date,\n                          chr.expiration =expirations[expiration>chr.trade_date][order(expiration)][1,]$expiration,\n                          chr.option_type = 'c',\n                          chr.money_in_out = 'out',\n                          int.min_dollar = 0)\n  \n  int.vol <- dt.atm$iv\n  int.underlying <- dt.atm$underlying\n  dt.portfolio.slim <- dt.portfolio[trade_date==chr.trade_date]\n  dt.portfolio.slim <- dt.portfolio.slim[!trade_id %in% dt.portfolio.slim[qty==0]$trade_id]\n  int.current_delta <- dt.portfolio.slim[,sum(qty*delta)*100]\n  int.current_gamma <- dt.portfolio.slim[,sum(qty*gamma)*100]\n  int.oneSDmove <- int.underlying*(int.vol)*(sqrt(1/365))\n  int.range_gamma <- abs(int.oneSDmove * (int.current_gamma)/2 )\n  ls.metrics <- list(current_delta = int.current_delta, range_delta=int.range_gamma)\n  return(ls.metrics)\n  \n  \n}\n\n\n\n\noptVertical <- function(data=dt.spy, \n                        chr.trade_date, \n                        chr.expiration, \n                        chr.option_type, \n                        chr.long_short, \n                        vec.deltas=NULL, \n                        vec.strikes=NULL, \n                        int.qty = 1 ) {\n  \n  if (!is.null(vec.deltas)) {\n    dt.price_high <- getBestOption(data,chr.trade_date,chr.expiration,chr.option_type, int.min_delta = max(vec.deltas) )\n    dt.price_low <- getBestOption(data,chr.trade_date,chr.expiration,chr.option_type, int.min_delta = min(vec.deltas) )\n  }\n  \n  if (!is.null(vec.strikes)) {\n    dt.price_high <- getBestOption(data,chr.trade_date,chr.expiration,chr.option_type, int.strike = ifelse(chr.option_type == 'p', max(vec.strikes), min(vec.strikes)) )\n    dt.price_low <- getBestOption(data,chr.trade_date,chr.expiration,chr.option_type, int.strike = ifelse(chr.option_type == 'p', min(vec.strikes), max(vec.strikes)) )\n  }\n  \n  dt.price_high[,qty:=ifelse(chr.long_short == 'long', int.qty*1, int.qty*-1)]\n  dt.price_low[,qty:=ifelse(chr.long_short == 'long', int.qty*-1, int.qty*1)]\n  \n  dt.all <- rbind(dt.price_high, dt.price_low)\n  return(dt.all)\n  \n}\n\n\noptCalendar <- function(data=dt.spy, \n                        chr.long_short, \n                        chr.trade_date, \n                        chr.expiration_front, \n                        chr.expiration_back,  \n                        chr.option_type, \n                        int.min_delta = NULL,\n                        int.strike = NULL,\n                        chr.money_in_out = NULL, \n                        int.min_dollar = NULL, \n                        int.qty = 1) {\n  \n  dt.slim <- data[expiration %in% c(chr.expiration_front, chr.expiration_back) & call_put== chr.option_type][trade_date==chr.trade_date]\n  dt.slim <- dt.slim[strike %in% dt.spy.slim[,.N, by=strike][N==2]$strike]\n  dt.front_month <- getBestOption(data= dt.spy.slim, chr.trade_date, chr.expiration=chr.expiration_front, chr.option_type, chr.money_in_out='out', int.min_dollar)\n  dt.back_month <- getBestOption(data= dt.spy.slim, chr.trade_date, chr.expiration=chr.expiration_back, chr.option_type, chr.money_in_out='out', int.min_dollar, int.strike = dt.front_month$strike)\n  dt.front_month[,qty:=ifelse(chr.long_short=='long', -1*int.qty, int.qty)]\n  dt.back_month[,qty:=ifelse(chr.long_short=='long', int.qty, -1*int.qty)]\n  dt.pos <- rbind(dt.front_month, dt.back_month)\n  return(dt.pos)\n  \n}\n\n\n\n\ncaclulateRealizedVol <- function(data=dt.spy, chr.date_start, chr.date_end, chr.symbol = 'SPY') {\n  \n  dt.spy.tmp <- data[trade_date %between% c(chr.date_start, chr.date_end)]\n  dt.underlying <- dt.spy.tmp[,list(underlying=mean(underlying)), by=list(date=trade_date)]\n  dt.underlying[,underlying_yesterday := c(NA, dt.underlying$underlying[-nrow(dt.underlying)])]\n  dt.underlying[,returns:=underlying/underlying_yesterday - 1]\n  int.stdev <- dt.underlying[,sd(returns, na.rm=T)]\n  int.vol <- int.stdev*sqrt(262)\n  return(int.vol)\n  \n}\n",
    "created" : 1448304676655.000,
    "dirty" : false,
    "encoding" : "",
    "folds" : "",
    "hash" : "4218125170",
    "id" : "88FE15AB",
    "lastKnownWriteTime" : 1448339839,
    "path" : "~/rPackageFunctions/toCreateOptionFunctions.R",
    "project_path" : null,
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "type" : "r_source"
}